# 2021_08_25_2131_lets_get_rusty

- Tags: #icarus #coding #letsgetrusty #youtube #videoseries

- [Let's Get Rusty](https://www.youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8)

---

## Chapter 1: ULTIMATE Rust Lang Tutorial! - Getting Started (1)

- [Link](https://www.youtube.com/watch?v=OX9HJsJUDxA&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=1)

- Install Rust on computer.
- Install Rust language addons on VS Code.
  - "rust-analyzer" extension
  - Install Rust language server if prompted
  - "Cargo" is the build system and package manager.
  - `cargo --version`
  - `cargo new hello_cargo`
  - cargo automatically adds a git repository with .gitignore, src with main.rs file.
  - `cargo build`
  - "Cargo.lock" specifies direct dependencies.
  - "debug" fold has all our program files to run.
  - `cargo run` to run the program.
  - `cargo --help` for all commands.
  - `cargo check` check for error without running, much faster than running program.

---

## Chapter 2: ULTIMATE Rust Lang Tutorial! - Programming a Guessing Game (2)

- [Link](https://www.youtube.com/watch?v=H0xBSbnQYds&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=2)

- `cargo new guessing_game`
- `String::new();` String is a type in Rust standard library and is a "growable string", new is an associated function or other languages call it static functions.
  - TIP: AKA also owned type, not borrowed like str.
  - TIP: Owned strings are always UTF-8. If need non UTF-8, use `OsString`.
  - TIP: Can't index it. AKA `newString[0]`
- Variables immutable by default, we have to add `mut`.
- Bring io library into scope with `use std::io;`
- `.read_line` returns Result type.
- `.expect` returns message if fail.
- Add to Cargo.toml file under dependencies, `rand = "0.5.5"`
  - TIP: I actually added `rand = "0.8.4"`
  - Bring Rng trait into scope with `rand::Rng;`
  - TIP: Instead of `gen_range(1, 101);`, I fixed with `gen_range(1..101);`
- `use std::cmp::Ordering;` allows us to compare.
- Add loop to not exit program after a guess.
- `.parse` returns a Result so we can choose to handle to tell users to enter correct type of input.
- Add `colored = "2.0.0"` to dependencies. Use with `use colored::*;`.

---

## Chapter 3: ULTIMATE Rust Lang Tutorial! - Common Programming Concepts (3)

- [Link](https://www.youtube.com/watch?v=2V0JaMVjzws&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=3)

- **let**
- Variables are immutable by default.
- use `let mut x` to make it mutable.
- constant values use `const` and convention to use all CAPITALS with underscores.

```rust
// Standard way to shadow
let x = 5;
let x = 6;

// Improved way to shadow.
let x = 5;
let changed_x = x;
```

- **const**

  - const can't use `mut`.
  - Must be type annotated.
  - Can't set any computed values or values returned from a function.
  - Can use numeric literals by using underscore.
  - Can't shadow const values.

- **Shadowing**

  - Shadowing allows to make a new variable from an existing name.
  - Preserves the mutability of the variables.
  - A pro is being able to change type of the variables.

- **Scalar vs Compound data types**

  - Scalar are single types: integers, floats, booleans, char.

    - Rust numbers defaults to 32bit integer.
    - Many types like signed, unsigned, and varying bits.
    - Can be represented with decimal, hex, octal, binary and byte (u8 only, max value of 255).
    - With integer overflow, rust **panics in debug mode** and rust **will complement wrap in release builds**.
    - If 255 is the last value, it will wrap so that 256 becomes 0 and 257 becomes 1.
    - Many basic math operations and unicode chars.

  - Compound are multiple types: tuples, arrays, functions

  ```rust
  // ==Tuples: fixed size array of related data of different types.
  // Use destructuring or dot notation to grab data.
  let tup = ("Let's Get Rusty!", 100_000);

  // Destructuring access.
  let (channel, sub_count) = tup;

  // Dot notation access.
  let sub_count - tup.1;

  // ==Arrays: fixed size arrays of the same type.
  let error_codes = [200, 404, 500];

  // Brackets access.
  // Won't allow you to access out of bounds indices.
  let not_found = error_codes[1];

  // Create array with 8 values all set to 0.
  let byte = [0; 8];

  // ==Functions
  // Uses lower case with snake case for fn names.
  fn main() {
    let sum = my_function(11, 22);
    println!("The sum is: {}", sum);
  }

  // Statements don't return a value, Expressions return a value.
  // Can omit semicolon and return statement if it's last line.
  // Also need to declare return type if not define in function.
  // Notice -> i32 and we return x + y to match this type.
  fn my_function(x, y) -> i32 {
    println!("The value of x is: {}", x);
    println!("The value of x is: {}", y);

    // Can be simplified...
    // let sum = x + y;
    // return sum;

    // To this...but need to add return type after params.
    // Notice there are no semicolon.
    x + y
  }
  ```

- **Control Flow**

  - Conditional must be a boolean.
  - Ternary operations possible.

  ```rust
  let condition = true;

  // This is how you do a ternary operator.
  // The conditional is never in parantheses like JS.
  let number = if condition { 5 } else { 6 };
  ```

- **Loop types**

- Basic loop

```rust
fn main() {
  let mut counter = 0;
  let result = loop {
    counter += 1;

    // The conditional is never in parantheses like JS.
    if counter == 10 {
      break counter;
    }
  };

  println!("The result is {}", result);
}
```

- While Loop

```rust
fn main() {
  let mut number = 3;

  while number != 0 {
    println!("{}!", number);

    number -= 1;
  }

  println!("Liftoff!!");
}
```

- For In Loop

```rust
fn main() {
  let a = [10,20,30,40,50];

  // a.iter gives us iterable for array.
  for element in a.iter() {
    println!("The value is: {}", element);
  }

  for number in 1..4 {
    println!("{}!", number);
  }
}
```

- **Comments**
- `//` for single comments.
- `/* */` for multi-line comment.

---

## Chapter 4: ULTIMATE Rust Lang Tutorial! - Understanding Ownership (4)

- [Link](https://www.youtube.com/watch?v=VFIOSWy93H0&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=4)

- Ownership is Rust's unique way to make memory safe guarantees without a garbage collector.
- References, Borrowing, Slice type, data layout in memory

### What is Ownership?

- Ownership is a way to manage memory.

- Java and C# (Garbage Collection)

  - PROS: error free, faster write time.
  - CONS: No control over memory, slower and unpredictable runtime performance, larger program size.

- C and C++ (Manual Memory Management)

  - PROS: Control over memory, faster runtime, smaller program size.
  - CONS Error prone, slower write time.

- Rust (Ownership model)

  - PROS: Control over memory, error free, faster runtime, smaller program size.
  - CONS: Slower write time. Learning curve fighting with the borrow checker.

- The trade-off is worth it to learn the ownership model.
- Rust remains error free because it does a bunch of compile time checks.
- You can opt out of memory safety with `unsafe` keyword.

### Stack and Heap

- Stack is fixed size and cannot grow/shrink during runtime.
- Stack frames are created with functions run.
- Stack frame size are calculated at compile time so the variables must have known file sizes.
- Variables live as long as the stack frame lives.

- Heaps are less organized, not fixed size, can last as long as user wishes.
- Pushing and accessing to the stack is faster than allocating to the heap.

- **Extra Notes**
- [Stack and Heap Explanation](https://www.youtube.com/watch?v=_8-ht2AKyH4)
  - Looking at dynamic memory with C and C++
  - There's the Code, static/global, stack, heap
  - A new stack frame is instantiated when a function is ran like main().
  - The stack frame sits on the stack and it's allocated in the stack memory.
  - The variables are also stored on the stack frame.
  - The variables last as long as the stack frame lasts.
  - Stack overflow is when we have too many functions running and it overflows the allocated memory initiated when the program started. AKA stack overflow.
  - This can happen when lets say only 1MB is allocated for the stack and a recursion runs, this causes our program to crash.
  - In reality, the size of the stack depends on the OS and compiler.
  - Heaps are are can dynamic grow and shrink as needed. It's considered a free store of memory. Also called dynamic memory allocation.
  - _malloc_ - looks on the heap for free space, allocates memory for you, then gives you back a pointer address to the location. If it can't find a space, it will return null.
  - _calloc_
  - _realloc_
  - _free_ - removes the memory portion of whatever reference you pass in. It's the responsibility of the programmer to clear the heap because memory resource is precious.
  - _new_ - C++ uses new/delete instead of malloc/free in C.
  - _delete_

### 3 Ownership Rules To Remember

1. Each value in Rust has a variable that's called its owner.
2. There can only be one owner at a time.
3. When the owner goes out of scope, the value will be dropped.

- When the String type allocates to the heap, you need a pointer, the length, and the capacity.
- When String are "copied", it only copies the pointer.
- For simple types likes booleans/integers/characters, they are copied during reassignment. Simple types have a _Copy trait_ which allows it to be copied instead of moved.
- Rust does not create 2 references to a heap. Instead it does a _move_.

```rust
// ===Rust defaults to moving a value, not copy.
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);

// ===If you want to copy, use clone.
let s2 = s1.clone();
```

### Ownerships in functions

```rust
// ===When strings get passed into a function, the function takes ownership
fn main() {
  let s = String::from("hello");
  takes_ownership(s);
  println!("{}", s); // s cannot be borrowed because ownership was taken by the function.
}

fn takes_ownership(some_string) {
  println!("{}", some_string);
}

// ===You can also move ownership.
fn main() {
  // String from function return stored on s1 variable.
  let s1 = gives_ownership();
  println!("s1 = {}", s1);
}

fn gives_ownership() -> String {
  let some_string = String::from("hello");

  some_string
}

// ===Can also take and give back ownership.
let s2 = String::from("hello");
let s3 = takes_and_gives_back(s2);
println!("{}", s3);

fn takes_and_gives_back(a_string: String) -> String {
  a_string
}
```

### References

- _References_ are like pointers to the address in memory.
- _Borrowing_ is when you pass a reference into a function parameter. The ownership is not transferred.
- References are immutable by default. You can modify them in the borrow function.
- You can make references mutable by using `&mut`.

```rust
// ===Borrowing in action
fn main() {
  let s1 = String::from("hello");
  let len = calculate_length(&s1);
  println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
  let length = s.len();
  length
}

// ===Can also pass mutable references
fn main() {
  let mut s1 = String::from("hello");
  change(&mut s1);
}

fn change(some_string: &mut String) {
  some_string.push_str(", world");
}
```

### Data Races

- Can't do this because there can be an async in data.
- No way to sync data properly, so Rust will panic here.
- SOLUTION: Switch back `s` variable back to immutable.

```rust
fn main() {
  let mut s = String::from("hello");

  let r1 = &mut s;
  let r2 = &mut s;
}
```

- You can't have a mutable reference to another mutable reference already exists.
- Rust expects thethe value to be consistent.

- The scope of a reference starts when introduced and ends when it is used.
- So after it's used, you can introduce a new mutable reference.

```rust
fn main() {
  let mut s = String::from("hello");

  let s1 = &s;
  let s2 = &s;

  println!("s1 = {}, s2 = {}", s1, s2);

  // s1 and s2 have gone out of scope, so you can make a new mutable "instance".
  let s3 = &mut s;
  println!("{}", s3);
}
```

### Dangling References

- **The Rules of References**
  1. At any given time, you can have either one mutable reference or any number of immutable references.
  2. References must always be valid.

### Slices

- Slices lets you reference a contiguous portion in a collection.
- A return value is not tied to the string itself.
- String literals are actually string slices to the location in binary.
- `&s` is string reference vs `&str` is a string slice.
- You can also do slices of other collections like arrays.

---

## Chapter 5: ULTIMATE Rust Lang Tutorial! - Using Structs To Structure Related Data (5)

- [Link](https://www.youtube.com/watch?v=n3bPhdiJm9I&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=5)

### Using Structs to contruct data

- Structs lets you group related data together of different types.

- _Field init shorthand syntax_ is like javascripts short-hand key-value name when making an javascript object.

```rust
// ===Building basic struct and constructing instances.

// Related data of all different types.
struct User {
  username: String,
  email: String,
  sign_in_count: u64,
  active: boolean,
}

fn main() {
  let mut user1 = User {
    email: String::from("tim@mail.com");
    username: String::from("tim");
    active: true,
    sign_in_count: 1
  };

  // Read and Update to struct.
  let name = user1.username;
  user1.username = String::from("timothy");

  // Instantiating a new user with a function.
  let user2 = build_user(
    String::from("ksx@mail.com"),
    String::from("ksx");
  )

  // Using default types to create a user.
  let user3 = User {
    email: String::from("otc@mail.com"),
    email: String::from("otc"),
    ..user2
  }
}

fn build_user(email, username: String) -> User {
  // Using Field init shorthand syntax
  User {
    email,
    username,
    active: true,
    sign_in_count: 1
  }
}
```

- We can also build tuple structs.
- There are also unit structs which we cover in chapter 10.

```rust
// ===Different field types but different type.
fn main() {
  struct Color(i32, i32, i32);
  struct Point(i32, i32, i32);
}
```

- Now use a struct to calculate area.

```rust
// ===Basic app
fn main() {
  let width = 30;
  let height = 50;

  println!(
    "The area of the rectangle is {} square pixels.",
    area(width, height)
  );
}

fn area(width: u32, height: u32) -> u32 {
  width * height
}


// ===Using function tuple instead params
// But dimensions is ambiguous, don't know if W or H.
fn main() {
  let rect = (30, 50);

  println!(
    "The area of the rectangle is {} square pixels.",
    area(rect)
  );
}

fn area(dimensions: (u32, u32)) -> u32 {
  dimensions.0 * dimensions.1
}

// ===Refactoring using struct
// Allow compiler to use Debug trait.
#[derive(Debug)]
struct Rectangle {
  width: u32,
  height: u32,
}

fn main() {
  let rect = Rectangle(
    width: 30,
    height: 50
  )

  // We can also use {:?}
  println!("react: {:#?}", rect);

  println!(
    "The area of the rectangle is {} square pixels.",
    area(&rect)
  );
}

// Take in a reference because we just want to use fields.
fn area(rectangle: &Rectangle) -> u32 {
  rectangle.width * rectangle.height
}
```

- Now we will involve _methods_.
- Methods are like functions but tied to an instance of a struct.
- `&self` is the method being called on. You can also take references and sometimes ownership as well.

- Rust has a feature called _automatic referencing/dereferencing_ where it will use methods on the struct without problems. In C++, it matters if you use a method from an object directly or a method from a pointer to an object. Rust is more relaxed.
- To differentiate between methods and functions, methods have the parameter `&self`.
- _Associate functions_ don't have to be tied to an instance of a struct, they can be standalone. They don't use `&self`.

```rust

#[derive(Debug)]
struct Rectangle {
  width: u32,
  height: u32,
}

// This is the new method.
// We can also removed area function from before.
impl Rectangle {
  fn area(&self) -> u32 {
    self.width * self.height
  }

  // Let's also implement new can_hold method.
  fn can_hold(&self, other: &Rectangle) -> bool {
    self.width > other.width && self.height > other.height
  }
}

// Associated functions don't use &self.
impl Rectangle {
  fn square(size: u32) -> Rectangle {
    Rectangle {
      width: size,
      height: size
    }
  }
}

fn main() {
  let rect = Rectangle(
    width: 30,
    height: 50
  )

  let rect1 = Rectangle {
    width: 20,
    height 40,
  }

  let rect2 = Rectangle {
    width: 40,
    height 50,
  }

  // Can be used by refering to the struct, but don't need to make own instance.
  let rect3 = Rectangle::square(25);

  println!("rect can hold rect1: {}", rect.can_hold(&rect1)); // true

  println!("rect can hold rect12: {}", rect.can_hold(&rect12)); // false

  // We can also use {:?}
  println!("react: {:#?}", rect);

  println!(
    "The area of the rectangle is {} square pixels.",
    rect.area()
  );
}
```

---

## Chapter 6: ULTIMATE Rust Lang Tutorial! - Enums and Pattern Matching (6)

- [Link](https://www.youtube.com/watch?v=DSZqIJhkNCM&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=6)

### Enums

- Enums vary in other languages and most similar to other functional programing languages.
- `Option` enum is a specific type.
- Use enums when you know the variant types.
- Let's use IPv4 or IPv6, there can only be 2.

```rust
// ===Using basic enum.
// We can also specify the types if we want to.
enum IpAddrKind {
  // V4(String),
  V6(String),

  // If we want to store 8 bit integers, we can do that too.
  V4(u8, u8, u8, u8)
}

// We use a struct to capture the actual IP Address.
struct IpAddr {
  kind: IpAddrKind,
  address: String,
}

fn main() {
  let four = IpAddrKind::V4;
  let six = IpAddrKind::V6;

  // // Using enum Let's us tie 2 different types together in a structure.
  // let localhost = IpAddr {
  //   kind: V4,
  //   address: String::from("127.0.0.1")
  // }

  // // Using struct with enum types is more concise to write.
  // // It's like specifying the variant when we initiate, aka V4.
  // let localhost = IpAddrKind::V4(String::from("127.0.0.1"));

  // If we want to store 8 bit integers.
  let localhost = IpAddr::V4(127, 0, 0, 1);
}

fn route(ip_kind: IpAddrKind) {}
```

- Enums supports a variety of types also.
- We can write each of the variants as structs but they would all have to be of the same type.

```rust
// Enums are more convenient.
enum Message {
  Quit,
  Move { x: i32, y: i32},
  Write(String),
  ChangeColor(i32, i32, i32),
}

// // Structs are too verbose to write.
// struct QuitMessage; // unit struct
// struct MoveMessage {
//   x: i32,
//   y: i32,
// }
// struct WriteMessage(String); // tuple struct
// struct ChangeColorMessage(i32, i32, i32); // tuple struct

imple Message {
  fn some_function() {
    println!("Hello")
  }
}
```

### Option Enum

- Rust does not have `null` value, but has `None`.
- Option enum has Some and None variant.
- It's also included in standard scope.

```rust
// ===Using Option enums.

// // Enum structure.
// enum Option<T> {
//   Some(T),
//   None
// }

fn main() {
  let some_number = Some(5);
  let some_string = Some("A string");

  // You must annotate the type for None variant.
  let absent_number: Option<i32> = None;
}
```

- Enums also has useful methods like `unwrap_or`.
- More exploration should be done.

```rust
fn main() {
  let x: i8 = 5;
  let y: Option<i8> = Some(5);

  // If y is set to None, we'll still get sum = 5;
  let sum = x + y.upwrap_or(0);
}
```

### Match expression

- Use match expressions to match through enum branches is useful also.
- Using match expressions with returning functions also let's us do additional things.

```rust
fn main() {
  value_in_cents(Coin::Quarter(UsState::Alaska));
}

#[derive(Debug)]
enum UsState {
  Alabama,
  Alaska,
  Arizone,
  // ...
}

enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
  match coin {
    Coin::Penny => {
      println!("Lucky penny!");
      1
    }
    Coin::Nickel => 5,
    Coin::Dime => 10,
    Coin::Quarter(state) => {
      println!("State quarter from {:?}!)", state);
      25
    }
  }
}
```

### Returning unit type for match variant

- Match expressions are exhuastive, so we can return a unit type with `_`.

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
  match x {
    Some => Some(i + 1),
    _ => None
  }
}
```

### If let match expressions

- This syntax is more confusing to write but know it exists.

```rust
fn main() {
  let some_value = Some(3);

  // Standard syntax.
  match some_value {
    Some(3) => println!("three"),
    _ => (),
  }

  // If let syntax is less verbose.
  // It just targets 1 variant more succintly but confusing the write.
  if let Some(3) = some_value {
    println!("three");
  }
}
```

---

## Chapter 7: ULTIMATE Rust Lang Tutorial! - Managing Growing Projects (7)

- [Link](https://www.youtube.com/watch?v=5RPXgDQrjio&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=7)

- We need to manage code in a bigger projects instead of just a single file as we've been doing.
- A _package_ stores _crates_.
- _Crates_ can be _binary_ (can be executed) or _library_ (use by other programs) crate.
- _Crates_ has _modules_ and lets you organize code and control privacy rules.
- _Workspaces_ are meant for very large projects.

- With the default `cargo new`, we do have a binary crate called `main.rs`.
- This is the crate root and where rust starts at.
- You can make a library crate called `lib.rs`.
- Neither has to be listed in the `Cargo.toml` file but our package does have 2 crates.

### Rules for Crates

1. Need at least 1 crate for package.
2. Package can have any amount of binary crates.
3. Can have zero or 1 library crate.

- If you need more binary crates, you would create a folder called `bin`.

### Creating a new project with library crate

- Use `cargo new --lib restaurant` will create project with a library crate with the lib flag.
- It won't have a `main.rs` by default.
- Think of module tree like a computer directory tree.

- Use absolute and relative paths to navigate.
- Notice absolute paths start with `crate` in front.
- Absolute path - `crate::front_of_house::hosting::add_to_waitlist();`
- Relative path - `front_of_house::hosting::add_to_waitlist();`
- By default, all children of modules are private.
- Use `pub` in front of mod and fn to expose them.
- Use `super::` to access the parent module.

```rust
mod front_of_house {
  pub mod hosting {
    pub fn add_to_waitlist() {}
  }
}

pub fn eat_at_restaurant() {
  // Absolute path.
  crate::front_of_house::hosting::add_to_waitlist();

  // Relative path.
  front_of_house::hosting::add_to_waitlist();
}
```

### Structs, Enums, functions, and fields are private by default

- We need to add pub to expose parts we need to use.
- If a field is private, you can create another struct directly.
- With structs, all their methods and fields are private by default until exposed.
- With enums, their variants become public if exposed.

```rust
// ===Using structs.
mod back_of_house {
  // Add pub to access the struct.
  pub struct Breakfast {
    pub toast: String,
    seasonal_fruit: String,
  }

  impl Breakfast {
    // Add pub to access the method.
    pub fn summer(toast: &str) -> Breakfast {
      Breakfast {
        // Add pub to access the field.
        pub toast: String::from(toast),
        seasonal_fruit: String::from("peaches"),
      }
    }
  }

  pub fn eat_at_restaurant() {
    let mut meal = back_of_house::Breakfast::summer("Rye");

    meal.toast = String::from("Wheat");
  }
}
```

### Using paths into scopes to DRY code and export modules

- Using paths helps to differentiate if it's a local function or external one.
- If bringing in structs or enums, use the absolute path.
  - Unless functions have the same name, so bring in the parent module into scope.
  - So use `fmt::Result` or `io::Result<()>`
  - Or rename it by using `use std::io::Result as IoResult;`
- To _export modules_, we use pub keyword on the use path.
- If we want to use a dependency, add it to `Cargo.toml` file first, then add it to our scope by adding `use`.
- Use _nested paths_ or glob's to keep code clean and concise.

```rust
// Bringing in dependency and Rng trait from Cargo.toml.
use rand::{Rng, CryptoRng, ErrorKind::Transient};

// Another example.
use std::io::{self, Write};

// Using glob
use std::io:*;

// Combined using nested paths above.
// use rand::ErrorKind::Transient;
// use rand::CryptoRng;

mod front_of_house {
  pub mod hosting {
    pub fn add_to_waitlist() {}
  }
}

// Adding pub allows other modules to use our functions.
pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
  // If we bring paths into scope.
  hosting::add_to_waitlist();

  // Otherwise, we'd have to write this...
  front_of_house::hosting:add_to_waitlist();

  // Using our Rng trait.
  let secret_number = rand::thread_rng().gen_range(1, 101);
}
```

### Making new modules

- See 19:07 for this section, hard to explain.
- Declare module with `mod front_of_house;`
- Moving modules to a new folder called `front_of_house`.
- Inside, make `hosting.rs`.
- The basic tree.

  - `mod front_of_house;` in lib.rs.
  - `pub mod hosting;` in front_of_house.rs which sits same level as lib.rs.
  - `mod hosting;` in front_of_house.rs but references '/front_of_house/hosting.rs'. Thats a file inside a folder. The directory name has to be the same name as the parent module name which is 'front_of_house'.

---

## Chapter 8: ULTIMATE Rust Lang Tutorial! - Common Collections (8)

- [Link](https://www.youtube.com/watch?v=Zs-pS-egQSs&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=8)

- Collections are allocated on the heap and can shrink and grow as needed.

### Vector Creation

```rust
fn main() {
  // Arrays are fixed collections on the stack.
  // Vectors are collections stored on the heap.
  let a = [1, 2, 3];

  // Make a new vector of type i32. We have to specify type
  // because Rust doesn't know what we want.
  // Vectors can only store 1 type of data.
  let mut v:Vec<i32> = Vec::new();

  // Push items onto the vector.
  v.push(1);
  v.push(2);
  v.push(3);

  // Vectors and vector values go out of scope by the end.
  // This is a macro to initiate vector with values.
  // Note we don't have to specify vector types.
  {
    let v2 = vec![1, 2, 3];
  }
}
```

### Accessing Vector Elements

```rust
fn main() {
  // Creating a new vector.
  let v2 = vec![1, 2, 3, 4, 5];

  // 1st method: Accessing index (0 based).
  let third = &v[2];
  println!("The third element is {}", third);

  // This is run-time error (index out of bounds) because
  // heaps can shrink and grow until program is run.
  // Contrast with arrays which is of known length at
  // compile time. You would get a compile error there.
  let third = &v[20];

  // 2nd method: Using get.
  // If we want to handle run time errors gracefully.
  // .get() returns an Option so we need to write the result arms.
  match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("there is no third element."),
  }
}
```

### Iterating Over Vector Elements

```rust
fn main() {
  let mut v = vec![1, 2, 3, 4, 5];

  // For loop to print vector values.
  for i in &v {
    println!("{}", i);
  }

  // For loop and mutating vector values.
  for i in &mut v {
    *i += 50;
  }

  // Printing mutating vector values.
  for i in &v {
    println!("{}", i);
  }
}
```

### Storing Enum Variants Inside Vectors

```rust
fn main() {
    // Make an enum type so we can use in our vector
    // which can only store 1 type.
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    // Using enums add flexibility to vectors.
    // The type SpreadsheetCell can be of 3 types.
    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];

    // The only problem is when we try to access,
    // We need to let Rust know how to handle what type.
    match &row[1] {
      SpreadsheetCell::Int(i) => println!("{}", i),
      _ => println!("Not an integer!")
    }
}
```

### Strings are complicated

- Higher programming languages abstract away handling strings unlike lower programming languages.
- ASCII is a string encoding to converts between strings and 1's & 0's.
  - Each character is stored as a byte.
  - Only 7 bits (of 8 bits in a byte) can be used for a character.
  - There are 128 characters available. Pretty limiting...
- Other countries have other encoding standards for their languages.
  - This complicates all the encoding standards.
- Unicode was created to unify all the global standards and emojis.
  - Is backwards compatible with ASCII.
  - The first 128 characters are ASCII so you can parse ASCII text with Unicode.
- UTF-8 is a variable width encoding.
  - Could be 1, 2, 4 bytes.
  - Most popular encoding of unicode.

```rust
fn main() {
  // Strings are stored as a collection of UTF-8 encoded bytes.
  let s1 = String::new();
  let s2 = "initial contents";
  let s3 = s2.to_string();
  let s4 = String:: from("initial contents");

  // Strings can be written in English and other language characters.
  // See video 13:25.
}
```

### Appending To A String

```rust
// ===Using push and pust_str operators.
let mut s = String::from("foo");
s.push_str("bar");
s.push('!');

// ===Using + operator.
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3: String = s1 + &s2;

// s1 ownership was moved to s3.
// So we can't print it out.
println!("{}", s1);

// ==Using format macro.
// format! does not take ownership, so we can still use s1 and s2 later.
let s3: String = format!("{}{}", s1, s2);
```

### Accessing Strings Using Indexing

```rust
fn main() {
  // String access for English works fine.
  let hello: String = String::from("Hello");
  let c: char = hello[0];

  // Some Russian strings have varying bytes.
  // So index accessing doesn't work.
  // They can be bytes, scalar values, grapheme clusters.
  // See 15:32.
   let hello = String::from("Здравствуйте");
   let answer = &hello[0];

  // Rust doesn't know which types we want.
  // If we want bytes:
  for b in "नमस्ते".bytes() {
    println!("{}", b);
}

  // If we want chars:
  for c in "नमस्ते".chars() {
      println!("{}", c);
  }

  // If we want Grapheme clusters, library not included by default.
  // Import crate in cargo.toml file.
  unicode-segmentation = "1.7.1"

  use unicode_segmentation::UnicodeSegmentation;

  for g in "नमस्ते".graphemes(true) {
      println!("{}", g);
  }
}
```

### Hashmaps

```rust
// HashMap's allows you to store key value pairs
// The keys can be of any type.
// Uses hashing functions to store values in memory.
use std::collections::HashMap;

fn main() {
  let blue = String::from("Blue");
  let yellow = String::from("Yellow");

  // ===Creating new hashmap.
  let mut scores = HashMap::new();

  // ===Inserting key and values.
  // Insert will take ownership of owned strings here.
  // If we want to pass references, we have to use lifetimes.
  scores.insert(blue, 10);
  scores.insert(yellow, 50);

  println1("{}", blue);

  // ===Accessing values
  // get() returns an Option because we don't know if key exists.
  let team_name = String::from("Blue");
  let score = scores.get(&team_name);

  // ===Iterating over HashMap using tuples.
  for (key, value) in &scores{
    println!("{}: {}", key, value);)
  }

  // ===Updating HashMap
  let mut scores = HashMap::new();

  // Will overwrite existing key with value provided.
  scores.insert(String::from("Blue"), 10);
  scores.insert(String::from("Blue"), 20);

  // Only inserts value if there is no existing key.
  scores.entry(String::from("Yellow")).or_insert(30);
  scores.entry(String::from("Yellow")).or_insert(40);
}
```

### Counting Word Instances Example

```rust
fn main() {
  let text = "hello world wonderful world";

  let mut map = HashMap::new();

  // Loops string and splits by whitespace.
  for word in text.split_whitespace() {
    // Takes the word and inserts in hashmap if key doesn't exist.
    // or_insert() returns a mutable reference to our value so we can update below.
    let count = map.entry(word).or_insert(0);

    // Deference and then increment by 1.
    *count += 1;
  }

  print!("{:?}", map); // {"hello": 1, "world": 2, "wonderful": 1}
}
```

---

## Chapter 9: ULTIMATE Rust Lang Tutorial! - Error Handling (9)

- [Link](https://www.youtube.com/watch?v=wM6o70NAWUI&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=9)

### Panic macro

```rust
// ===Use panic when we want to exit program
// Otherwise, it's best to use error propagation.
fn main() {
  panic!("crash and burn");
}

// ===Using backtrace
// A backtrace helps is a code trace through functions that leads back to the error section.
// It's an environmental variable that you can run in the terminal.
// Run `RUST_BACKTRACE=1 cargo run` to run the backtrace.
fn main() {
  a();
}
fn a() {
  b();
}
fn b() {
  c(22);
}
fn c(num: i32) {
  if num == 22 {
    panic!("Don't pass in 22!");
  }
}

```

### Recoverable errors using Result enum

```rust
// ===Result enum has Ok and Err variants.
// Similar to Result with Some and None variants.
// It's structure:
enum Result<T, E> {
  Ok(T),
  Err(E)
}

// ===Using the Result enum
use std:fs::File;

fn main() {
  // Open method returns Result enum => Result<File, Error>.
  let f = File::open("hello.txt");

  // We have to handle the Result enum with match.
  // We use shadowing to make it easier.
  let f = match f {
    Ok(file) => file,
    Err(error) => panic!("Problem opening the file: {:?}", error),
  };
}

// ===Handling errors gracefully
use std:fs::File;
use std::io::ErrorKind;

fn main() {
  // Open method returns Result enum => Result<File, Error>.
  let f = File::open("hello.txt");

  // We have to handle the Result enum with match.
  // We use shadowing to make it easier.
  let f = match f {
    Ok(file) => file,
    // Checking the kind of error.
    Err(error) => match error.kind() {
      // Checking if we can create the file.
      ErrorKind::NotFound => match File::create("hello.txt") {
        Ok(fc) => fc,
        Err(e) => panic!("Problem creating the file: {:?}", e),
      }
      // Need exhaustive arm, this captures any other error than NotFound.
      other_error => {
        panic!("Problem opening the file: {:?}", other_error),
      }
    }
  };
}

// ===Writing error nest statements using closures
let f = File::open("hello.txt").unwrap_or_else(|error| {
  if error.kind() == ErrorKind::NotFound {
    File::create("hello.txt").unwrap_or_else( |error| {
      panic!("Problem creating the file: {:?}", error);
    })
  } else {
    panic!("Problem opening the file: {:?}", error);
  }
})
```

### Useful functions of Result enums

```rust
use std:fs::File;

fn main() {
  // Open method returns Result enum => Result<File, Error>.
  // upwrap() returns Result variant which returns the file or panics.
  // unwrap does the same thing as the match expression below.
  let f = File::open("hello.txt").unwrap();

  // Expect() lets us return more consise error message.
  let f = File::open("hello.txt").expect("Failed to open hello.txt");

  // // Replaced by unwrap().
  // let f = match f {
  //   Ok(file) => file,
  //   Err(error) => panic!("Problem opening the file: {:?}", error),
  // };
}
```

### Error Propagation and using ?'s

```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
  // ===Full example.
  // Attempt to open file.
  let f = File::open("hello.txt");

  // Handles Result enum.
  let mut f = match f {
    Ok(file) => file,
    Err(e) => return Err(e),
  };

  // Make mutable String
  let mut s = String::new();

  // Read the string from the file and store in the variable.
  match f.read_to_string(&mut s) {
    Ok(_) => Ok(s),
    Err(e) => Err(e),
  }

  // ===Using ?'s.
  // ? is similar to unwrap or expect method.
  // ? simplifying the match expressions.
  let mut f = File::open("hello.txt")?;
  let mut s = String::new();
  f.read_to_string(&mut s)?;
  Ok(s);

  // ===Chaining methods to DRY.
  let mut s = String::new();
  File::open("hello.txt")?.read_to_string(&mut s)?;
  Ok(s);

  // ===Using read_to_string to DRY code dramatically.
  use std::fs::{self, File};
  use std::io;
  use std::io::Read;

  // Useful method that results Result<String>.
  fs::read_to_string("hello.txt");
}
```

### Main is special in it's returns nothing or Result type

```rust
use std::error::Error;
use std::fs::File;

// Most functions can only use ? if it returns Result or Option.
// main() doesn't return anything.
// Need to return nothing or Result type.
fn main() -> Result<(), Box<dyn Error>> {
    let f = File::open("hello.txt")?;

    Ok(())
}
```

### When to use error handling

- Default should use Result enum and error propagation.
- Allows the use to decide how to handle the error.
- Use `panic!` for bad state example code, or prototype code.
- Use `unwrap()` or `expect()` in prototype phase or test code.
  - Or use that the function will succeed.

### Create custom types for validation

- See 14:30.
- In our guessing game, we want to always check if value is 1-100 for the whole program.
- You can create a custom struct to always know that our value is validated.

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

---

## Chapter 10a: ULTIMATE Rust Lang Tutorial! - Generic Types (10)

- [Link](https://www.youtube.com/watch?v=6rcTSxPJ6Bw&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=10)

- Generics, Traits, and Lifetimes are way to reduce code duplication.

```rust
// ===Reducing code duplication through extracting out the function.
fn main() {
  // The first list of numbers.
  let number_list = vec![34, 50, 25, 100, 65];
  let largest = get_largest(number_list);
  println!("The largest number is {}", largest);

  // The second list of numbers.
  let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];
  let largest = get_largest(number_list);
  println!("The largest number is {}", largest);
}

// Problem here is our function is tied to a concrete type.
fn get_largest(number_list: Vec<i32>) -> i32 {
  let mut largest = number_list[0];
  for number in number_list {
    if number > largest {
      largest = number;
    }
  }
  largest
}
```

### Using same function logic with different function types

```rust
// ===Using generics.
fn main() {
  // The first list of numbers.
  let number_list = vec![34, 50, 25, 100, 65];
  let largest = get_largest(number_list);
  println!("The largest number is {}", largest);

  // The second list of chars.
  let char_list = vec!['y', 'm', 'a', 'q'];
  let largest = get_largest(char_list);
  println!("The largest number is {}", largest);
}

// Problem here is our function is tied to a concrete type.
// So we change it to take T, which stands for Type.
// We also have to restrict the T to only items that can be ordered and copied.
// Copied are characters like numbers or chars.
fn get_largest<T: PartialOrd + Copy>(number_list: Vec<T>) -> T {
  let mut largest = number_list[0];
  for number in number_list {
    if number > largest {
      largest = number;
    }
  }
  largest
}
```

### Using struct with generics

```rust
// ===Generics with same types
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: 5.0, y: 10.0 };
    let p3 = Point { x: 5, y: 10.0 };
}

// ===Generics with different types
// T and U can be the same or different.
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: 5.0, y: 10.0 };
    let p3 = Point { x: 5, y: 10.0 };
}

// ===Implementing conditional methods with structs and generics.
struct Point<T> {
  x: T,
  y: T,
}

// Method implements on any Point struct with any types.
impl<T> Point<T> {
  fn x(&self) -> &T {
    &self.x
  }
}

// Method implements on any Point struct where types are float-64.
impl Point<f64> {
  fn y(&self) -> f64 {
    self.y
  }
}

fn main() {
  // Only the x method is available for implemention.
    let p = Point { x: 5, y: 10 };
    p.x();

  // Both x and y methods are available for implemention.
    let p1 = Point { x: 5.0, y: 10.0 };
    p1.y();
}
```

### A more complicated generic example

```rust
struct Point<T, U> {
  x: T,
  y: U,
}

// T and U are from p1 struct. V and W are from p2.
impl<T, U> Point<T, U> {
  fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
    // This returns the x value from p1 and y value from p2.
    Point {
      x: self.x,
      y: other.y,
    }
  }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

### Using enum with generics

```rust
fn main() {
  enum Option<T> {
      Some(T),
      None,
  }

  enum Result<T, E> {
      Ok(T),
      Err(E),
  }
}
```

### Performance with generics

```rust
// ===We use this in our code but it will transpile to 2 enums.
// enum Option<T> {
//   Some(T),
//   None
// }

// At compile time, Rust will make 2 separate enums
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

---

## Chapter 10b: ULTIMATE Rust Lang Tutorial! - Traits (11)

- [Link](https://www.youtube.com/watch?v=T0Xfltu4h3A&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=11)

- A trait is a method that we can share across different structs and enums.

```rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

// We are implementing the trait to the struct.
// It MUST implement summarize trait.
impl Summary for NewsArticle {
  fn summarize(&self) -> String {
    format!("{}, by {}", self.headline, self.author)
  }
}

pub struct Tweet {
  pub username: String,
  pub content: String,
  pub reply: bool,
  pub retweet: bool,
}

// We are implementing the trait to the struct.
// It MUST implement summarize trait.
impl Summary for Tweet {
  fn summarize(&self) -> String {
    format!("{}: {}", self.username, self.content)
  }
}

  // We want every type that implements the Summary trait
  // to be required to implement this summarize() that returns type String.
pub trait Summary {
  // We don't want to dictate the implementation with a body.
  fn summarize(&self) -> String;
}

fn main() {
  // Make an instance of Tweet struct.
  let tweet = Tweet {
    username: String::from("@johndoe"),
    content: String::from("Hello World!"),
    reply: false,
    retweet: false
  }

  // Make an instance of NewsArticle struct.
  let article = NewsArticle {
    author: String::from("John Doe"),
    headline: String::from("The Sky is Falling!"),
    content: String::from("The sky is not actually falling."),
  }

  // Each method will have their own trait and return specific outputs.
  println!("Tweet summary: {}", tweet.summarize());
  println!("Article summary: {}", article.summarize());
}
```

### Other implementations on the trait

```rust
impl Summary for Tweet {
  // REQUIRED: Now we have to implement the summarize_author default trait.
  fn summarize_author(&self) -> String {
    format!("@{}", self.username)
  }

  // NOT REQUIRED: We don't have to add this if we don't want to.
  fn summarize(&self) -> String {
    format!("{}: {}", self.username, self.content)
  }
}

pub trait Summary {
  // ===Implementing default traits
  // We can also implement a default implementation for the body.
  // As a test, you can remove the NewsArticle implementation,
  // this is the result that you will get.
  fn summary(&self) -> String {
    String::from("(Read More...)")
  }

  // ===Implementing traits that are shareable
  fn summarize_author(&self) -> String;

  fn summarize(&self) -> String {
    // Notice that we can use the other trait specified in the implmentation
    format!("(Read more from {}...)", self.summarize_author())
  }
}
```

### Using traits as parameters

```rust
// Not new info.
pub struct NewsArticle {
  pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

// Not new info.
impl Summary for NewsArticle {
  fn summarize(&self) -> String {
    format!("{}: {}", self.username, self.content)
  }
}

// This new function takes an argument that
// implements the Summary trait.
pub fn notify(item: &impl Summary) {
  println!("Breaking news! {}", item.summarize());
}

// // The above is actually syntactical sugar for "trait bound".
// pub fn notify(<T: Summary>(item: &T) {
//   println!("Breaking news! {}", item.summarize());
// }

fn main() {
    let article = NewsArticle {
    author: String::from("John Doe"),
    headline: String::from("The Sky is Falling!"),
    content: String::from("The sky is not actually falling."),
  }

  // The NewsArticle has the Summary trait implemented.
  notify(&article);
}

```

### Requirement to use exact same trait

```rust
// ===Wanting same types that implement a trait
// Both params takes anything that implements Summary.
// But we want both types to be the same.
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}

// We want both params to be of the same type T.
pub fn notify<T: Summary>(item1: &T, item2: &T) {}

// ===Wanting multiple trait implemented
pub fn notify(item1: &(impl Summary + Display), item2: &impl Summary) {}

pub fn notify<T: Summary + Display>(item1: &T, item2: &T) {}

// ===Using where clause to improve readability
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}

// Much easier to read using where caluse
fn some_function<T, U>(t: &T, u: &U) -> i32
  where T: Display + Clone,
        U: Clone + Debug
{
  // ...
}
```

### Using traits in function returns

```rust
pub trait Summary {
  fn summarize_author(&self) -> String;

  fn summarize(&self) -> String {
    format!("(Read more from {}...)", self.summarize_author())
  }
}

fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
fn main() {
  // The first part returns Tweet struct that implements Summary.
  // Useful in closures and iterators. More in chapter 13.
  // A restriction is that we can't use params that are bool
  // and returns a impl trait. It's Rust engine restriction
  // but we can get around it.
  println!("{}", returns_summarizable().summarize());
}
```

### Conditionally Implement Methods

```rust
// ===Useful for when we we want to validate the Type.
use std::fmt::Display;

struct Pair<T> {
  x: T,
  y: T,
}

// First trait that takes any generic Type.
impl<T> Pair<T> {
  fn new(x: T, y: T) -> Self {
    Self { x, y }
  }
}

// Second trait that takes any generic Type that implements Display and PartialOrd.
impl<T: Display + PartialOrd> Pair<T> {
  fn cmp_display(&self) {
      // Display + PartialOrd helps us validate x and y values so we can do >=.
      if self.x >= self.y {
          println!("The largest member is x = {}", self.x);
      } else {
          println!("The largest member is y = {}", self.y);
      }
  }
}
```

### Blanket implementations

```rust
// Any Type that implements Display, we will also apply the ToString trait on it.
// It's like a conditional trait applicator.
impl<T: Display> ToString for T {
    // --snip--
}
```

## Chapter 10c: ULTIMATE Rust Lang Tutorial! - Lifetimes (12)

- [Link](https://www.youtube.com/watch?v=juIINGuZyBc&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=12)

### Dangling references

```rust
// ===Borrow Checker
// This is Rust's checker for lifetimes.
fn main() {
  let r;

  {
      let x = 5;
      r = &x;
  } // x goes out of scope and is deallocated.

  // Since r was set inside the scope,
  // it is now pointing to invalid data.
  // This is considered a "dangling reference".
  println!("r: {}", r);
}
```

### Ambiguous lifetimes for Borrow Cheker

```rust
fn main() {
  let string1 = String::from("abcd");
  let string2 = String::from("xyz");

  // Borrow checker doesn't know if result is a dangling reference.
  let result = longest(string1.as_str(), string2.as_str());
  println!("The longest string is {}", result);
}

// Return of &str is ambiguous.
fn longest(x: &str, y: &str) -> &str {
  // Will it return x or y? Generic lifetime annotations help with this.
  if x.len() > y.len() {
    x
  } else {
    y
  }
}
```

### Generic lifetime annotations

```rust
// Generic lifetime annotations is generally called just lifetimes.
// It doesn't change the lifetime span but just explain the
// relationships between references.
fn main() {
  let string1 = String::from("abcd");
  let string2 = String::from("xyz");

  // Borrow checker doesn't know if result is a dangling reference.
  // It will understand that the result will be the "shorter" of the
  // two lifetimes that were used as arguments.
  let result = longest(string1.as_str(), string2.as_str());
  println!("The longest string is {}", result);
}

// Lifetimes start with a tick and first lower-case alphabet character.
// The return lifetime is the shortest lifetimes of the arguments.
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  if x.len() > y.len() {
    x
  } else {
    y
  }
}

// ===Quick reference for lifetime annotations.
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

### Understanding lifetime examples

```rust
// ===Example 1
fn main() {
  let string1 = String::from("abcd");

  // The result printed is the smaller of the 2 lifetimes
  // passed into result.
  // The borrow checker can see that string2 is still valid
  // when it goes to print. Everything works.
  {
    let string2 = String::from("xyz");
    let result = longest(string1.as_str(), string2.as_str());
    println!("The longest string is {}", result);
  }
}

// ===Example 2
fn main() {
  let string1 = String::from("abcd");

  // The result printed is the smaller of the 2 lifetimes
  // passed into result.
  {
    let string2 = String::from("xyz");
    let result = longest(string1.as_str(), string2.as_str());
  } // String2 lifetime has already ended here.

  // The string2 lifetime has already ended.
  // We can't print because string2 does not live long enough
  // and lasted only until the end of the inner scope.
  println!("The longest string is {}", result);
}

// Lifetimes start with a tick and first lower-case alphabet character.
// The return lifetime is the shortest lifetimes of the arguments.
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  if x.len() > y.len() {
    x
  } else {
    y
  }
}
```

### Specific lifetime cases

```rust
// ===When there's only 1 return.
// If we are only returning x, we don't need to declare
// lifetime for y.
// Also x lasts the whole function so it will be valid at the end.
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
  x
}


// ===Always return a lifetime from input.
// The return needs to reference something that was passed in
// because it can't use a lifetime created within the function,
// this would cause a dangling error.
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
  let result = String::from("really long string");
  result.as_str()
} // result will go out of scope here.

// ===Returning an owned type.
// This works because the String is an owned type
// and ownership is passed out of this function.
fn longest<'a>(x: &'a str, y: &str) -> String {
  let result = String::from("really long string");
  result
}
```

### Using struct lifetimes

```rust
// Uses the same lifetime syntax.
// The struct CANNOT outlive the lifetime passed in.
struct ImportantExcerpt<'a> {
  part: &'a str,
}

fn main() {
  let novel = String::from("Call me Ishmael.");
  let first_sentence = novel.split('.').next().expect("Could not find");
  let i = ImportantExcerpt {
    part: first_sentence,
  }
} // first_sentence goes out of scope.
// Can't use this struct anymore because variant is invalid.
```

### Lifetime ellison rules

```rust
// Rule 1: Each parameter that is a reference gets its own lifetime parameter.
// Rule 2: If there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters.
// Rule 3: If there are multiple input lifetime parameters, but one of them is &self or &mut self because this is a method, the lifetime of self is assigned to all output lifetime parameters.

// There are input and output lifetimes.

// This meets rules 1 and 2.
fn foo<'a>(x: &'a i32) -> &'a i32 {}
```

### Lifetime in methods

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    // Doesn't meet rules 1 and 2.
    // Does meet rule 3 so we don't have to annotate.
    // You can annotate the lifetimes if you want.
    fn return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

### Static lifetimes

```rust
fn main() {
  // Lasts as long as the program.
  // All string literals have static lifetimes since they life in binary.
  let s: &'static str = "I have a static lifetime.";
}
```

### All together chapter 10

```rust
use std::fmt::Display;

// We use trait bounds on ann parameter for any Type that implements Display.
// Rules 2 and 3 ellison doesn't apply here.
// We have to apply 1 because there are input lifetimes
// which we have to annotate.
fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

---

## Chapter 11: ULTIMATE Rust Lang Tutorial! - Testing Part 1 (13)

- [Link](https://www.youtube.com/watch?v=18-7NoNPO30&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=13)

- Rust can't check business logic so we need to make and run tests.

- `cargo new adder --lib` creates new library crate.
- `cargo test` to run tests.

```rust
// ===A test that passes.
#[cfg(test)]
mod tests {
  // Denotes that this is a test
    #[test]
    fn it_works() {
      assert_eq!(2 + 2, 4);
    }
}

// ===A test that fails.
// Will tell you which line the test fails.
    #[test]
    fn failing_test() {
      panic!("Make this test fail");
    }
```

```rust
// ===Testing actual code.
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

// If we had a bug in here say the lesser sign is a more than sign.
// The test will panic. The assert macro panics if evaluates to false.
impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

#[cfg(tests)]
mod tests {
  // You have to bring product code into test module into scope first.
  use super::*;

  #[test]
  fn larger_can_hold_smaller() {
      let larger = Rectangle {
          width: 8,
          height: 7,
      };

      let smaller = Rectangle {
          width: 5,
          height: 1,
      };

      // This tests passes.
      assert!(larger.can_hold(&smaller));

      // This tests fails but with the bang operator.
      assert!(!smaller.can_hold(&larger));
  }
}
```

```rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
  use super::*;

  // === This is an equal assertion test.
  #[test]
  fn it_adds_two() {
    // Checks that 2 values are equal.
    // It doesn't matter if values on left or right.
    assert_eq!(4, add_two(2));
  }

  // === This is an not equal assertion test.
    #[test]
  fn it_adds_two() {
    // Checks that 2 values are equal.
    // It doesn't matter if values on left or right.
    assert_ne!(3, add_two(2));
  }

  // ***
  // The values passed in both asserts must implement the PartialEq and Debug traits.
  // Most primitives and standard libraries already have this implemented.
  // Only when we make our own structures.
}
```

```rust
// ===Testing with custom messages.
pub fn greeting(name: &str) -> String {
    format!("Hello {}!", name)
}

#[cfg(test)]
mod tests {
  use:super::*;

  // ===This passes without hitch.
  // Errors with generic message if greeting() is changed.
  #[test]
  fn greeting_contains_name() {
    let result = greeting("Carol");
    assert!(result.contains("Carol"));
  }

  // ===Testing with custom message.
  #[test]
  fn greeting_contains_name() {
    let result = greeting("Carol");
    // assert() takes custom error message as 2nd parameter.
    // result is the filler for {}.
    assert!(
      result.contains("Carol"),
      "Greeting did not contain name, value was `{}`",
      result
    )
  }
}
```

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
  // ===Original implementation.
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
  use::super:*;

  // Should_panic looks at the failing case as we are expecting.
  // 200 should panic as suspected.
  #[test]
  #[should_panic]
  fn greater_than_100() {
    Guess::new(200);
  }
}
```

```rust
pub struct Guess {
    value: i32,
}

// ===Modified implementation to be more specific.
pub fn new(value: i32) -> Guess {
  if value < 1 {
    panic!(
        "Guess value must be greater than or equal to 1, got {}.",
        value
    );
  } else if value > 100 {
    panic!(
        "Guess value must be less than or equal to 100, got {}.",
        value
    );

    Guess { value }
  }
}

#[cfg(test)]
mod tests {
  use::super:*;

  // Now test should only panic if there's that string returned.
  // Results in passing because we expected panic.
  // -2 results in failure.
  #[test]
  #[should_panic(expected = "Guess value must be less than or equal to 100")]
  fn greater_than_100() {
    Guess::new(200);
  }
}
```

```rust
// ===Testing that returns Result type.
#[cfg(test)]
mod tests {
  #[test]
  fn it_works() -> Result<(), String> {
    if 2 + 3 == 4 {
      Ok(())
    } else {
      Err(String::from("two plus two does not equal four));
    }
  }
}
```

---

## Chapter 11: ULTIMATE Rust Lang Tutorial! - Testing Part 2 (14)

- [Link](https://www.youtube.com/watch?v=-L4nKAlmH3M&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=14)

- `cargo test --` goes to the test binary.
- `cargo test --help` shows commands you can run with the binary.
- `cargo test -- --help` shows commands you can pass to the binary.
- `cargo test -- --test-threads` sets thread amount to run in parallel. If serial, use 1.
- `cargo test -- --test-threads=1` is good like if multiple files are being modified on disk.
- `cargo test -- --show-output` shows you print statements for passing and failing cases.
  - By default, test outputs are captured but not printed on the screen.
- `cargo test one_hundred` runs test based on test name.
- `cargo test add` runs a subset of tests based on name provided. IE add_two() and add_three().
- `cargo test tests::` runs tests based on module name
- `#[ignore]` annotation will ignore that test.
- `cargo test -- --ignored` runs only the ignored tests.

### Test organizations

- _unit tests_ are small, test modules in isolation, and can test private interfaces.
  - Rust provides ability to test private functions even though you don't have to.
  - Unit tests are kept in the product code file.
  - Rust makes it difficult to put unit tests in different files and folders.
  - Just keep the tests in the same file.

```rust
// ===Unit test kept in product code file
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        // Unit tests can access private functions.
        // This child component can access everything outside (super::*).
        assert_eq!(4, internal_adder(2, 2));
    }
}
```

- _integration tests_ are external to your library.

  - Integration tests lives in test folder in the root.
  - You can name the test files whatever, Rust knows to look in this folder.
  - Each test file is turned into a new crate.
  - So you have to bring libraries into scope with `use`.

```rust
// ===Integration file in tests directory
use adder;

// Don't need `$[cfg(test)]` annotation. Rust knows.
#[test]
fn it_adds_two() {
  // Must call the public API.
    assert_eq!(4, adder::add_two(2));
}
```

### Making common shared code

- 2 methods: `tests/common.rs` or `tests/common/mod.rs`.
- If you want a common methods to share, make a tests/common/mod.rs

> Nuance: You can't do integration tests on binary crates. So you will see binary crates thinly wrap around libary crates so we can test it.

```rust
// ===Code in either file.
pub fn setup() {
    // setup code specific to your library's tests would go here
}

// ===To use methods in other files.
use adder;

// How to bring in the common code file.
// Will look for both common.rs or common/mod.rs.
mod common;

#[test]
fn it_adds_two() {
    // How to call the method.
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
```

---

## Chapter 12: Writing a CLI App in Rust! - Part 1 (15)

- [Link](https://www.youtube.com/watch?v=XYkiwsplDTg&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=15)

- grep is a basic app that lets us search strings in files.
- Generally, we want to separate responsibilities.
- There's a pattern in rust to make a binary crate to call functions from library crate.
- [rust_minigrep repo](https://github.com/timh1203/rust_minigrep)

---

## Chapter 12: Writing a CLI App in Rust! - Part 2 (16)

- [Link](https://www.youtube.com/watch?v=AABHxixn6Cw&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=16)

- Moving logic into `lib.rs` crate. `main.rs` still holds the main logic.
- Private by default, need to add pub to fn, struct, and fields.
- `lib.rs` will be our primary library crate.
- `cargo run test poem.txt` to check that our app still works.

### Using TDD

- Then do TDD where we write failing code before working code.
- Unused parameters needs an `_`. IE `pub fn search<'a>(_query: &str, _contents: &'a str) -> Vec<&'a str> {}`
- `cargo test` for testing.
- `cargo run frog poem.txt` for run() and returns 1 line.
- `cargo run dog poem.txt` for run() but returns 0 lines.
- `to_lowercase` method returns a new string and not mutate original string.

### Environment Variables

- `use std::env;` to use environmental variables.
- `cargo run to poem.txt` for run() but returns 2 lines.
- If using bash, can use `export CASE_INSENSITIVE=true` and get 3 lines.
- If unset, can use `unset CASE_INSENSITIVE` and get 2 lines.

### Printing out to stderr instead of stdout

- Command line programs send errors to standard error streams (stdout).
- One can direct the stdout using `>` on the terminal.
- Users can send errors to a file instead.
- `cargo run > output.txt` to send errors out to a file.
  - The error `Problem parsing arguments: Not enough parameters.` is saved in the file.
- If you want to not store errors in stdout, you can use `eprintln!()`.
  - This will make the errors print out on the terminal.
- We can also redirect the results from our app into a file.
  - `cargo run to poem.txt > output.txt` to get those poem lines that matches.
  - This outputs 5 lines for me with what we normally see in the terminal.
  - Nothing will print in the terminal also.

---

## Chapter 13: ULTIMATE Rust Lang Tutorial! - Closures in Rust (18)

- [Link](https://www.youtube.com/watch?v=kZXJvLfjUS4&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=17)

- Closures are like functions but are anonymous.
- Can be stored as variables.
- Can also be used as input parameters.
- Captures variables in scope they are defined.

### Basic example of expensive call we want to solve

```rust
// ===Without a closure
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -> u32 {
  println!("Calculating slowly...");
  thread::sleep(Duration::from_secs(2));
  intensity
}

fn main() {
  let simulated_intensity = 10;
  let simulated_random_number = 7;

  generate_workout(simulated_intensity, simulated_random_number);
}

// We are simulating expensive function calls.
// Issue 1: calling fn multiple places, have to update all callsites.
// Issue 2: calling function multiple times and it's an expensive function.
fn generate_workout(intensity: u32, random_number: u32) {
    // This could work but we're always running 1 expensive calculation.
    // Let's make a closure instead.
    let expensive_result = simulated_expensive_calculation(intensity)

    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            expensive_result
        );
        println!(
            "Next, do {} situps!",
            expensive_result
        );
    } else {
        // We still ran the expensive calculation first despite not using here.
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_result
            );
        }
    }
}
```

### Now we use a closure to optimize

```rust
// ===Making a closure
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -> u32 {
  println!("Calculating slowly...");
  thread::sleep(Duration::from_secs(2));
  intensity
}

fn main() {
  let simulated_intensity = 10;
  let simulated_random_number = 7;

  generate_workout(simulated_intensity, simulated_random_number);
}

fn generate_workout(intensity: u32, random_number: u32) {
    // Closure are an anonymous stored in a variable.
    // Variable is not storing return value but closure itself.
    // Calling the closure is similar to calling a function.
    let expensive_closure = |num| {
      println!("Calculating slowly...");
      thread::sleep(Duration::from_secs(2));
      num
    };

    // Closures can only have 1 concrete type and the type is set the first time.
    // You can supply the types for input and output but it's more verbose.
    let example_closure = |x| x;

    // Closure type set to string.
    let s = example_closure(String::from("Hello"));
    let n = example_closure(5); // This will error. Already set as string.

    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            example_closure(intensity)
        );
        println!(
            "Next, do {} situps!",
            example_closure(intensity)
        );
    } else {
        // We still ran the expensive calculation first despite not using here.
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                example_closure(intensity)
            );
        }
    }
}
```

### Memoizing results with a struct

```rust
// ===Using struct to memoize closure and result
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -> u32 {
  println!("Calculating slowly...");
  thread::sleep(Duration::from_secs(2));
  intensity
}

fn main() {
  let simulated_intensity = 10;
  let simulated_random_number = 7;

  generate_workout(simulated_intensity, simulated_random_number);
}

// All closures implement one of 3 traits: Fn, FnMut, FnOnce
struct Cacher<T>
where
  T: Fn(u32) -> u32,
{
  calculation: T, // Stores any closure meeting the trait bound.
  value: Option<u32>, // Our calculation will return value and plug here. 1st call is None.
}

// Implement the method.
// Fn is a hard coded type. You can just use generics instead.
impl<T> Cacher<T>
where
  T: Fn(u32) -> u32,
{
  // New is a constructor function.
  fn new(calculation: T) -> Cacher<T> {
    Cacher {
      calculation,
      value: None,
    }
  }

  // First method.
  // The problem with this is that the value won't update the second time.
  // A challenge is to implement a hash map
  // using the arg as the key and the closure(arg) as the value.
  fn value(&mut self, arg: u32) -> u32 {
    match self.value {
      // The second call will return the value.
      Some(v) => v,

      // The first call will hit None because self.value does not exist yet.
      None => {
        // Runs the closure with provided arg.
        let v = (self.calculation)(arg);

        // Caches the value on the struct.
        self.value = Some(v);

        // Return the value.
        v
      }
    }
  }
}

fn generate_workout(intensity: u32, random_number: u32) {
    // Now we add a Cacher to store the closure and calculated value.
    // Now the closure be called only once and the value is cached.
    let mut cached_result = Cacher::new(|num| {
      println!("Calculating slowly...");
      thread::sleep(Duration::from_secs(2));
      num
    });

    // The cached_results are quicker to access now because of O(1).
    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            cached_result.value(intensity)
        );
        println!(
            "Next, do {} situps!",
            cached_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                cached_result.value(intensity)
            );
        }
    }
}
```

### The Scope of a Closure

- Rust infers which trait to use base on how you use values in environment.
- `FnOnce` takes ownership of variable in environment.
  - Once refers to fact that closures can't take ownership of the same variable more than once.
- `FnMut` mutably borrows values.
- `Fn` immutably borrows values.

```rust
fn main() {
  let x = vec![1, 2, 3];

  // Closures captures variables in scope it was defined.
  // Incurs extra memory cost to store the context.
  let equal_to_x = |z| z == x;

  // Functions do not do this capture so is less expensive.
  // However, this will error and ask us to use closures
  // because x is being used from outside the fn.
  // fn equal_to_x(z: i32) -> bool {
  //   z == x
  // }

  // Closure taking forcibly ownership of variable by using `move`.
  // Helpful when moving variables from one context to another.
  // x will not be able to be used after this line because ownership was taken by the closure.
  // let equal_to_x = move |z| z == x;

  println!("can't use x here: {:?}", x);

  let y = vec![1, 2, 3];

  assert!(equal_to_x(y));
}
```

---

## Chapter 13: ULTIMATE Rust Lang Tutorial! - Iterators in Rust (18)

- [Link](https://www.youtube.com/watch?v=4GcKrj4By8k&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=18)

- Iterator pattern allows you to loop through a sequence of elements regardless of how they are stored.
- They could be array, hashmap, map, or custom data structures.
- Iterating over arrays might be straightforward, but other items will not be.
- Iterators encapsulate the logic to do operations and provided by the standard library.

```rust
// ===Basic Iterator
}
fn main() {
  let v1 = vec![1, 2, 3];

  // Apply iterator to the vector.
  // Iterators said to be lazy.
  // Nothing happens until we consume it.
  let v1_iter = v1.iter();

  // Now we loop over the values.
  for value in v1_iter {
    println!("Got: {} ", value);
  }
}
```

### Anatomy of an Iterator

- `.iter()` getting back immutable types with each next().
- `.iter_mut()` getting back mutable types with each next().
- `.into_iter()` for using owned types.

```rust
// Iterator trait defined in the standard library.
pub trait Iterator {
  type Item;

  // Item is an associate type. Basically you have to have Item type implemented.
  // The only method mandatory to be implemented.
  // Next passes Item along with Some and ends in None when reaches the end.
  // Need &mut self to change the item being passed along so we can track positioning.
  fn next(&mut self) -> Option<Self::Item>;

  // methods with default implementations elided
}

#[test]
fn iterator_demonstration() {
  let v1 = vec![1, 2, 3];

  // ===Makes immutable references with every next() call.
  let mut v1_iter = v1.iter();

  // ===Makes mutable references with every next() call.
  // let mut v1_iter = v1.iter_mut();

  // Notice we have immutable references return.
  assert_eq!(v1_iter.next(), Some(&1));
  assert_eq!(v1_iter.next(), Some(&2));
  assert_eq!(v1_iter.next(), Some(&3));
  assert_eq!(v1_iter.next(), None);

  // ===Using owned types.
  let mut v1_iter = v1.into_iter();

  // Notice we have immutable references return.
  assert_eq!(v1_iter.next(), Some(1));
  assert_eq!(v1_iter.next(), Some(2));
  assert_eq!(v1_iter.next(), Some(3));
  assert_eq!(v1_iter.next(), None);
}
```

### Other iterator methods, Adaptors, Consumers

- _Adaptors_ takes an iterator and return another iterator.
- _Consumers_ takes an iterator and returns some other type like a string, collection, or any other type.

```rust
// ===Consumer Iterator Example
#[test]
fn iterator_sum() {
  let v1 = vec![1, 2, 3];

  let v1_iter = v1.iter();

  // Sum() method provided by standard library.
  let total = v1_iter.sum();

  assert_eq!(total, 6);
}

// ===Adaptor Iterator Example
fn main() {
  let v1 = vec![1, 2, 3];

  // map() takes a closure to make an iterator.
  // The iterator applies the closure to each item in the collection.
  // map() returns an iterator and needs to be consumed (lazy).
  // collect() is a consumption method and turns it into a collection.
  let v2 = Vec<_> = v1.iter().map(|x| x + 1).collect();

  // Assert that each item is incremented by 1.
  assert_eq!(v2, vec![2, 3, 4]);
}
```

### Iterators with Closures that capture their environment

```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

// Takes a vector of shoes and a shoe size.
// Filters out shoes that match shoe size and return all matching shoes in vector.
// Results in an Iterator so we need to call Collect on it to consume.
// Notice we use into_iter() because Vec<Shoe> is not a primitive type.
// Notice we still have access to shoe_size despite it not being in the closure.
fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
  shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

fn main() {

mod tests {
  use super::*;

  #[test]
  fn filters_by_size() {
    let shoes = vec![
      Shoe {
        size: 10,
        style: String::from("sneaker"),
      },
      Shoe {
        size: 13,
        style: String::from("sandal"),
      },
      Shoe {
        size: 10,
        style: String::from("boot"),
      },
    ]

    let in_my_size = shoes_in_my_size(shoes, 10));

    // We assert that 2 shoes will come in size 10
    assert_eq!(
      in_my_size,
      vec![
        Shoe {
          size: 10,
          style: String::from("sneaker"),
        },
        Shoe {
          size: 10,
          style: String::from("boot"),
        },
      ])
  }
}
```

### Making a custom counter Iterator

```rust
struct Counter {
  count: u32,
}

impl Counter {
  fn new() -> Counter {
    Counter { count: 0 }
  }
}

impl Iterator for Counter {
  // Always set associate type.
  type Item = u32;

  // Counts only up to 5.
  fn next(&mut self) -> Option<Self::Item> {
    if self.count < 5 {
      self.count += 1;
      Some(self.count)
  } else {
    None
  }
}

fn main(){}

// Test that it counts up to 5.
#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
```

### Other Iterator Methods

```rust
// zip() combines 2 iterators with the first that was called upon and 2nd inside the argument
// it creates a pair of values
// skip() skips nth element of number being passed in.
// Adaptor methods: zip(), map(), filter()
// Consumer Methods: sum()
#[test]
fn using_other_iterator_trait_methods() {
  let sum: u32 = Counter::new()
    .zip(Counter::new().skip(1))
    .map(|a, b| a * b)
    .filter(|x| x % 3 == 0)
    .sum();
  assert_eq!(18, sum);
}
```

## Chapter 13: Iterators in Practice (19)

- [Link](https://www.youtube.com/watch?v=rb63xJEjaZU&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=19)

- Look at the rust-minigrep project.
- We will be redoing a part of our minigrep program to not use clone().
- Instead we will use Iterators.
- Should we use loops or iterators for performance reasons? Either.
- Rust follows zero cost abstraction principles.
- There are no performance hits for using higher level abstractions.
- Using loops or iterators are the same in term of performance.
- Developers prefer iterators because the nice abstraction and the nice methods it provides.
- It comes down to preference.

---

## Chapter 14: Publishing a Rust Crate! (20)

- [Link](https://www.youtube.com/watch?v=4TI153PIEDQ&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=20)

- Focus on Cargo and crates.io.

- Rust has 2 profiles to control how your files compile.
  - There's _dev_ and _release_.
  - Both has good defaults for each.
  - dev build is unoptimized + debuginfo.
  - release build is optimized.
  - Can configure in toml file.

```rust
// Cargo.toml
// Default optimization levels
// More optimization takes longer build time but makes faster run time.

[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
```

### Documentation comments

- Uses `///` instead of 2 for regular comments.
- Uses markdown to compile the document.
- Rust will turn your documentation comments into html for easy to read.
- `cargo doc --open` will open our documentation with web browser.
- There are also _Panics_, _Errors_, _Safety_ sections like Examples as well.
- `cargo test` will also run the test code below.

- lib.rs:

````rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
````

### Documenting our crate

- Using `//!` documents the item containing the comment.
- Basically helps describe out crate.

### Re-exporting

- It's hard to see the enums because you have to click on the module "kinds".
- We use re-export so it shows up at the top level.
- This also allows you to import directly from the top level of the library.
- Since we have re-exported them.
- Like `use art::kinds::PrimaryColor;` to `use art::PrimaryColor;`
- This helps people get familiar with your program quickly.
- They don't have to learn the internals of your libraries.

```rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        // --snip--
    }
}
```

### Using crates.io

- Set up an account and must use a Github account.
- Go to account settings and make a new token.
- Assign a name to your token and create.
- Run the `cargo login API_KEY` command in terminal.
- You need to check your metadata.
- Have to make sure all commits are made, add description & license.
- Your library is published permanently because others may rely on your library.
- Update the semantic version in toml file.
- You can't delete but you can stop versions from being downloaded further.
- `cargo yank --vers 0.1.0` will support exisiting users but new users can't download it.
- `cargo yank --vers 0.1.0 --undo` to unyank something.

> **Make sure your crate name is unique and change your file path is updated to use the crate name also.**

---

## Chapter 14: Cargo Workspaces (21)

- [Link](https://www.youtube.com/watch?v=70_9IIsQfjs&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=21)

- Workspaces helps you manage multiple related packages.
- Packages share a common cargo.lock file, output directory, and various settings like profiles.

- Workspaces have packages called _workspace members_.
- `cargo new adder` to make new package.
- `cargo build` at root package.
- Rust compiles all the packages to a target directory.
- Saves a lot of time by not having multiple target directory in each package.
- `cargo new add-one --lib` to add the next package.
- To use add_one() in adder, we have to add it as a dependency in adder package.
  - Rust doesn't assume that packages automatically depend on each other, we have to declare.
- See [Repo](https://github.com/timh1203/rust_cargo_workspaces).
- Better to see than describe.
- `cargo build` to rebuild our app.
- `cargo run -p adder` to run a specified package.
- Each package has a toml file. It combines in the root toml file.
- Cargo.lock will show that we have the new rand crate.
  - You need to add rand to each package dependency if you want to use it.
- `cargo test -p add-one` when we only want to run test on 1 file.
- If you want to publish a crate, you have to publish in each package individually.

### Installing Binaries

- Rust developers can use tools from other rust developers from crates.io.
- We need binary targets so we can execute it.
- All packages installed with cargo installed are stored in the bin directory.
- "$Home/.cargo/bin" make sure to have this in your environmental variables so you can run commands.

- `cargo install ripgrep` will install tool.
- When I run command I get as the path:`C:\Users\Khoassant\.cargo\bin\rg.exe`
- `rg --help` to test if your path is working.
- Something about running sub command for `cargo-something` by running `cargo something`.

---

## Chapter 15: The Box Smart Pointer in Rust (22)

- [Link](https://www.youtube.com/watch?v=m76sRj2VgGo&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=22)

- Chapter 15 covers smart pointers.
- A _pointer_ is a fixed-size data that has an address that points to an address in memory where the real data is stored.
  - A _reference_ is the most common type of pointer in Rust.
  - Usually, references don't own the data they point to, just borrow.
  - References don't have much overhead because they don't do anything special.
- _Smart Pointers_ are special pointers that has extra metadata and capabilities.
  - An example is a smart pointer that keeps tracks of many owners.
  - Then the smart owners clear the data after there are no more owners.
  - Most cases, smart pointers they own the data that they point to.
  - An example smart pointer example are strings and vectors.
  - For example, a capability of Strings is that can keep data valid in UTF-8.
- Usually implemented using structs.
  - Also implement _deref_ and _drop_ traits.
  - _Deref_ allows instances of your smart pointer struct to be treated like references.
  - So you can write code that works with references or smart pointers.
  - _Drop_ allows you to customize code that runs when an instance of the smart pointer goes out of scope.

### Box Smart Pointer

- Box is a common smart pointer that allows you to allocate memory on the heap.
- Doesn't have much capability.
- Normally used:

1. When you don't know the exact size of data at compile time but need to use it later where you want to use but need to know the exact size.
2. When you want to use a large amount of data but want to make sure it's not copied.
3. When you want to implement a value implements a specific trait, not being a specific type. AKA _trait object_ in chapter 17.

- A contrived example where storing on a heap is easier.
- This just introduces Box smart pointer:

```rust
fn main() {
  // We are storing 5 on the heap.
  // A reference is kept on the stack that points to that heap location.
  let b = Box::new(5);

  println!("b = {}", b);

  // When b goes out of scope,
  // Box pointer on stack is deallocated.
  // Data on heap is also deallocated.
}
```

### Recursive Enums

- We don't know how much space is needed for the CONS at compile time.
- So instead we store references to those items.
- Think about enum _Cons_ which come from Lisp.

  - It looks like a linked list to me. But the structure is more like cells containing cells.
  - [Wiki Cons Entry](https://en.wikipedia.org/wiki/Cons)
  - Cons not commonly used in Rust, better to use a vector for lists.

- `cargo check` to see errors.
  - Cons has "recursive type has infinite size"
  - List has "recursive without indirection"
  - "insert some indirection to make `List` represent

```rust
// Harder for Rust to calculate space.
// Can't calculate List size.
enum List {
  Cons(i32, List),
  Nil,
}

// // Rust can calculate space for this easily as an example.
// enum Message {
//   Quit,
//   Move { x: i32, y: i32 },
//   Write(String),
//   ChangeColor(i32, i32, i32),
// }

use List::{Cons, Nil};

fn main() {
  let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

- We can fix using `Box`.

```rust
// Box stores a Box smart pointer.
// It will be a fixed sized pointer.
// Now rust knows exactly how to allocate space.
enum List {
  Cons(i32, Box<List>),
  Nil,
}

use List::{Cons, Nil};

// We also have to wrap the Cons with Box so it can know to make smart pointers.
fn main() {
  let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```

---

## Chapter 15: Smart Pointers in Rust - The Deref Trait (23)

- [Link](https://www.youtube.com/watch?v=dYEC6NElVOg&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=23)

- _Deref_ trait allows you to customize behavior of deref operator.
- Now we use Box pointer to make assertion work.

```rust
fn main() {
  // y is a reference that points to where 5 is stored.
  let x = 5;
  let y = &x;

  assert_eq!(5, x);
  // This will fail because can't compare int to a reference.
  assert_eq!(5, *y);
}
```

```rust
// Bring deref trait into scope...
use std::ops::Deref;

// MyBox is different from Box from standard library.
// MyBox's x is not stored on the heap.
struct MyBox<T>(T);

impl<T> MyBox<T> {
  fn new(x: T) -> MyBox(T) {
    MyBox(x)
  }
}

// Implement Deref trait.
impl<T> Deref for MyBox<T> {
  // Associated types are different ways of declaring generic parameter.
  type Target = T;

  // Can also use &Self::Target in &T. Both are equal.
  fn deref(&self) -> &T {
    // MyBox is a tuple struct so return 0th index.
    &self.0
  }
}

fn main() {
  let x = 5;
  // y is pointing to a copy of 5 because it's a primitive.
  // deref trait works the same like a reference.
  // ownership is NOT transferred here.
  let y = MyBox::new(x);

  assert_eq!(5, x);

  // *y is actually calling *(y.deref()));
  // Actually returns a reference instead of value because of ownership system.
  assert_eq!(5, *y);
}
```

### Deref trait

- Rust only knows how to deref without the Deref trait by default.
- Otherwise you need to implement the trait.
- Rust has _automatic dereferencing_ to handle regular references and derefs the same way.

### Implicit Deref Coercion

- Automatic conversion for types that implement deref traits.
- Can use `Deref` trait for immutable references.
- `DerefMut` trait also available for mutable references.

```rust
fn main() {
  let m = MyBox::new(String::from("Rust"));
  hello(&m);
  // &MyBox<String> -> &String -> &str
  // Rust does these conversions at compile time to match the function signature.
  // &String also implements Deref trait.
}

fn hello(name: &str) {
  println!("Hello, {}!", name);
}
```

### Deref Coercion with Mutability

- Rust does deref coercion in 3 cases:

1. From immutable reference to immutable reference. IE `&T` to `&U`
2. From mutable reference to mutable reference. IE `&mut T` to `&mut U`
3. From mutable reference to immutable reference. IE `&mut T` to `&U`

- Will not work for immutable reference to mutable reference because of borrowing rules.
- The borrowing rule: Can only have 1 mutable reference to a piece of data in a scope.
- Case 3 does not break that rule.

---

## Chapter 15: Smart Pointers in Rust - The Drop Trait (24)

[Link](https://www.youtube.com/watch?v=RPWZcTYBS4k&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=24)

- _Drop_ trait can be implemented on any type
- Customizes what happens when something goes out of scope.
- Drop trait is almost always used when using smart pointers.
- With drop, we don't have to worry about handling memory.

```rust
// ===Using standard drop implementation.
struct CustomSmartPointer {
  data: String,
}

// Drop is implemented by default in the prelude and already in scope.
impl Drop for CustomSmartPointer {
  fn drop(&mut self) {
    println!("Dropping CustomSmartPointer with data `{}`!", self.data);
  }
}

// Drop normal runs at the end of each scope.
// Drop runs on variables in reverse order...so d gets dropped and then c.
fn main() {
  let c = CustomSmartPointer {
    data: String::from("c variable"),
  }
  let d = CustomSmartPointer {
    data: String::from("d variable"),
  }

  println!("CustomSmartPointers created.");
}

// ===Using drop function
fn main() {
  let c = CustomSmartPointer {
    data: String::from("some data"),
  };
  println!("CustomSmartPointer created.");

  // We can't call the drop directly leads to a double free.
  // c.drop();

  // Use the drop method provided by standard library.
  // This will drop before the end of main.
  // We would want to use this to remove a "lock", more later.
  // Different from drop implementation we made earlier.
  drop(c);
  println!("CustomSmartPointer dropped before the end of main.");
}
```

---

## Chapter 15: Smart Pointers in Rust - Reference Counting (25)

- [Link](https://www.youtube.com/watch?v=M9Owp3iLigg&list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&index=25)

- _Reference Counting_ smart pointer allows to share ownership.
- It does this by keeping track of refrences to a value.
- We have to use RC because sometimes a value has multiple values.
  - Like a node that has many edges that point to the same node.
  - The node should is technically owned by many edges.
  - We should clean up the value only when the last reference has used the value.
  - Think TV in a living room, the last person should turn off the TV. Not anywhere in between.
- The RC we use here is only useful for _single-threaded_ programming.
  - Chapter 16 has more for _multi-threaded_.

## Using Cons list as example.

- Think of Cons list like Linked List.
- But there's 2 nodes that link to the next same node.

```rust
enum List {
  Cons(i32, Box<List>),
  Nil,
}

use crate::List::{Cons, Nil};

fn main() {
  let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));

  // b and c are the references that both use a.
  // Cons take ownership so c would be invalid here.
  let b = Cons(3, Box:: new(a));
  let c = Cons(4, Box:: new(a));
}
```

- Something about not wanting to use lifetimes in our enums.
- Lifetimes wouldn't work since we have `Nil`, we want to use Rc instead.

```rust
// Bring library into scope.
use std::rc::Rc;

// Add Rc to our enum.
enum List {
  Cons(i32, Rc<List>),
  Nil,
}

use crate::List::{Cons, Nil};

fn main() {
  // Need to set a to Rc::new also because we are passing into b and c.
  let a = Rc::new(5, Rc::new(Cons(10, Rc::new(Nil))));

  // clone here only increments the reference count, equivalent to a.clone().
  // Better to use the first syntax. IE Rc::clone
  // clone does NOT make a deep copy.
  // Rc::clone also expects an owned type so you can't pass any references. IE &a.
  // Can't pass in a directly because ownership would be passed into b, not available for c.
  let b = Cons(3, Rc::clone(&a));
  let c = Cons(4, Rc::clone(&a));
}
```

## Example of Rc

- Rc does not modify the value, only reads it.
- When there's mutability with the value, there's a pattern we'll see in the next chapter.
-

```rust
fn main() {
    // Rc increments by 1.
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));

    // Rc increments to 2.
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));

    {
      // Rc increments to 3.
      // Blocked scope so c can go out of scope at the end of block.
      // You can see that our Rc decrements in the return.
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }

    // Rc decrements to 2.
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}

// Return ->
// count after creating a = 1
// count after creating b = 2
// count after creating c = 3
// count after c goes out of scope = 2
```

---
